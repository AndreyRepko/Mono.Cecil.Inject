<?xml version="1.0" encoding="utf-8"?>
<topic id="ovr_injection_flags" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <!--
    <summary>
      <para>Optional summary abstract</para>
    </summary>
    -->
    <introduction>
      <autoOutline />
      <para>
       Cecil.Inject includes a simple, yet rather versatile, set of methods to inject methods into others.
       In fact, all of the injection is handled by a single <codeEntityReference autoUpgrade="true">M:Mono.Cecil.Inject.InjectionDefinition.Inject(System.Int32,System.Int32,Mono.Cecil.Inject.InjectDirection)</codeEntityReference> method.
       To make Cecil.Inject support a large variety of different injection methods, the library explicitly specifies the signature of the injection methods. The signature is customisable using different combinations of <codeEntityReference>T:Mono.Cecil.Inject.InjectFlags</codeEntityReference>.
       <markup><br/></markup>
       In this section we discuss the supported injection method signature and how to edit it using the injection flags.
      </para>
    </introduction>
    <!-- Add one or more top-level section elements.  These are collapsible.
         If using <autoOutline />, add an address attribute to identify it
         and specify a title so that it can be jumped to with a hyperlink. -->
    <section address="injection_flags">
      <title>Injection flags</title>
      <content>
        <!-- Uncomment this to create a sub-section outline
        <autoOutline /> -->
        <para>
         Cecil.Inject allows to configure what information is passed to the injection method and how the injection method should perform method redirection. 
         As you will see later, this is done by specifying a combination of different <codeEntityReference>T:Mono.Cecil.Inject.InjectFlags</codeEntityReference>. 
         The flags can be combined with a logical OR operation (<codeInline>|</codeInline> operator).
        </para>
        <para>
         Below is the generic layout of an injection method that Cecil.Inject supports.
         
         <code language="cs">
          public static &lt;3&gt; MyHook(&lt;1&gt;, &lt;2&gt;, &lt;4&gt;, &lt;5&gt;, &lt;6&gt;, &lt;7&gt;);
         </code>
         
         The number surrounded by arrow brackets (i.e. <codeInline>&lt;1&gt;</codeInline>) means that the type of the value that goes in it depends on which <codeEntityReference>T:Mono.Cecil.Inject.InjectFlags</codeEntityReference> is specified. 
        </para>
        <para>
         Next, below there are two tables with all available <codeEntityReference>T:Mono.Cecil.Inject.InjectFlags</codeEntityReference>. The first table specifies how to alter the template depending on the chosen flags. The second table contains description for each of the flags.
        </para>
      </content>
      <sections>
          <section address="subsection_template_table">
              <title>Template table</title>
              <content>
               <table>
                <tableHeader>
                 <row>
                   <entry><para><codeEntityReference>T:Mono.Cecil.Inject.InjectFlags</codeEntityReference> value</para></entry>
                   <entry><para>How the template is affected (<legacyItalic>IF SET</legacyItalic>)</para></entry>
                   <entry><para>How the template is affected (<legacyItalic>IF NOT SET</legacyItalic>)</para></entry>
                  </row>
                </tableHeader>
                  <row>
                   <entry><para><codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.None</codeEntityReference></para></entry>
                   <entry><para>&lt;3&gt; = <codeInline>void</codeInline></para></entry>
                   <entry>Cannot be unset.</entry>
                  </row>
                  <row>
                   <entry><para><codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.PassTag</codeEntityReference></para></entry>
                   <entry><para>&lt;1&gt; = <codeInline>int</codeInline></para></entry>
                   <entry>&lt;1&gt; = empty</entry>
                  </row>
                  <row>
                   <entry><para><codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.PassInvokingInstance</codeEntityReference></para></entry>
                   <entry><para>&lt;2&gt; = <codeInline>T</codeInline></para></entry>
                   <entry>&lt;2&gt; = empty</entry>
                  </row>
                  <row>
                   <entry><para><codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.ModifyReturn</codeEntityReference></para></entry>
                   <entry><para>
                    &lt;3&gt; = <codeInline>bool</codeInline><markup><br/></markup>
                    <legacyItalic>If target returns <codeInline>void</codeInline>: </legacyItalic>&lt;4&gt; = empty<markup><br/></markup>
                    <legacyItalic>Otherwise: </legacyItalic>&lt;4&gt; = <codeInline>out T</codeInline>
                    </para></entry>
                   <entry>
                   	&lt;3&gt; = <codeInline>void</codeInline><markup><br/></markup>
                   	&lt;4&gt; = empty
                   </entry>
                  </row>
                  <row>
                   <entry><para><codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.PassLocals</codeEntityReference></para></entry>
                   <entry><para>&lt;5&gt; = <codeInline>ref T_1, ref T_2, ...</codeInline></para></entry>
                   <entry>&lt;5&gt; = empty</entry>
                  </row>
                  <row>
                   <entry><para><codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.PassFields</codeEntityReference></para></entry>
                   <entry><para>&lt;6&gt; = <codeInline>ref T_1, ref T_2, ...</codeInline></para></entry>
                   <entry>&lt;6&gt; = empty</entry>
                  </row>
                  <row>
                   <entry><para><codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.PassParametersVal</codeEntityReference></para></entry>
                   <entry><para>&lt;7&gt; = <codeInline>T_1, T_2, ...</codeInline></para></entry>
                   <entry>&lt;7&gt; = empty</entry>
                  </row>
                  <row>
                   <entry><para><codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.PassParametersRef</codeEntityReference></para></entry>
                   <entry><para>&lt;7&gt; = <codeInline>ref T_1, ref T_2, ...</codeInline></para></entry>
                   <entry>&lt;7&gt; = empty</entry>
                  </row>
                </table>
              </content>
          </section>
          <section address="subsection_description">
              <title>Description table</title>
              <content>
               <table>
                <tableHeader>
                 <row>
                   <entry><para><codeEntityReference>T:Mono.Cecil.Inject.InjectFlags</codeEntityReference> value</para></entry>
                   <entry><para>Description</para></entry>
                  </row>
                </tableHeader>
                  <row>
                   <entry><para><codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.None</codeEntityReference></para></entry>
                   <entry><para>Nothing is passed to the injection method. The method is simply called when the injection target runs, and the injection method does not alter the execution of the target in any way.</para></entry>
                  </row>
                  <row>
                   <entry><para><codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.PassTag</codeEntityReference></para></entry>
                   <entry><para>A 32-bit signed integer is passed to the injection method. The value of the tag is specified when performing the injection. Useful if you have the method injection into multiple targets and need to differentiate between the targets that call the injection method.</para></entry>
                  </row>
                  <row>
                   <entry><para><codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.PassInvokingInstance</codeEntityReference></para></entry>
                   <entry><para>Pass the instance of the type <legacyBold>T</legacyBold> that contains the injection target and that called the injection method. In other words: passes <codeInline>this</codeInline> to the injection method. Note that the target method <legacyItalic>must not be static</legacyItalic>. If the target is static, but this flag is set, Cecil.Inject will handle the error depending on how the injector is created.</para></entry>
                  </row>
                  <row>
                   <entry><para><codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.ModifyReturn</codeEntityReference></para></entry>
                   <entry><para>Specifies that the injection method is injected by method redirection. The return value of the injection method determines the behaviour of the target: if the injection method returns <codeInline>true</codeInline>, the target returns right after running the injection method; if set to <codeInline>false</codeInline>, the target continues executing its logic after having returned from the injection method. Moreover, if the target has a return type <legacyBold>T</legacyBold> that is not <codeInline>void</codeInline>, the injection method specifies its own custom return value. The custom return value is used only if the injection method itself returns <codeInline>true</codeInline>.</para></entry>
                  </row>
                  <row>
                   <entry><para><codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.PassLocals</codeEntityReference></para></entry>
                   <entry><para>Pass local variables of types <legacyBold>T_1</legacyBold>, <legacyBold>T_2</legacyBold>, etc. found in the injection method itself. Note that the value of them depends on the place where the injection method is injected -- the value might even not be initialized at the time the target calls the injection method. The locals are always passed by reference, which means that you can alter their value and thus change how the target executes its code.</para></entry>
                  </row>
                  <row>
                   <entry><para><codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.PassFields</codeEntityReference></para></entry>
                   <entry><para>Pass type fields of types <legacyBold>T_1</legacyBold>, <legacyBold>T_2</legacyBold>, etc. found in the type that contains the injection target. Note that the method <legacyItalic>must not be static</legacyItalic>. If the target is static, but this flag is set, Cecil.Inject will handle the error depending on how the injector is created.</para></entry>
                  </row>
                  <row>
                   <entry><para><codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.PassParametersVal</codeEntityReference></para></entry>
                   <entry><para>Passes the parameters of types <legacyBold>T_1</legacyBold>, <legacyBold>T_2</legacyBold>, etc. from the injection target. The parameters are passed by value and thus changing them will not alter them in the target method itself. The parameters must be in the same order as in the injection target.<markup><br/></markup> In Cecil.Inject 1.1+ some of the injector creators allow that the injection method doesn't have all of the parameters in its signature (so-called <legacyItalic>partial parameter passing</legacyItalic>). <legacyItalic>Cannot be combined with <codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.PassParametersRef</codeEntityReference>.</legacyItalic></para></entry>
                  </row>
                  <row>
                   <entry><para><codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.PassParametersRef</codeEntityReference></para></entry>
                   <entry><para>Passes the parameters of types <legacyBold>T_1</legacyBold>, <legacyBold>T_2</legacyBold>, etc. from the injection target . The parameters are passed by reference, which means that changing their values will change the value of the parameters of the target method. The parameters must be in the same order as in the injection target.<markup><br/></markup> In Cecil.Inject 1.1+ some of the injector creators allow that the injection method doesn't have all of the parameters in its signature (so-called p<legacyItalic>artial parameter passing</legacyItalic>). <legacyItalic>Cannot be combined with <codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.PassParametersVal</codeEntityReference>.</legacyItalic></para></entry>
                  </row>
                  <row>
                   <entry><para><codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.All_Val</codeEntityReference></para></entry>
                   <entry><para>Shorthand for flag combination <codeInline>PassTag | PassInvokingInstance | PassLocals | PassFields | PassParametersVal</codeInline>.</para></entry>
                  </row>
                  <row>
                   <entry><para><codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.All_Ref</codeEntityReference></para></entry>
                   <entry><para>Shorthand for flag combination <codeInline>PassTag | PassInvokingInstance | PassLocals | PassFields | PassParametersRef</codeInline>.</para></entry>
                  </row>
                </table>
              </content>
          </section>
          <section address="subsection_important">
           <title>Important things to consider</title>
           <content>
           <list class="bullet">
            <listItem><para><legacyItalic>All hooks must always be public and static.</legacyItalic></para></listItem>
            <listItem><para>The injection flags only specify <legacyItalic>what types</legacyItalic> are inserted in the template. The name of the parameters of the injection method are not important.</para></listItem>
            <listItem><para>If the injection target has generic parameters and either <codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.PassParametersVal</codeEntityReference> or <codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.PassParametersRef</codeEntityReference> is set, the injection method <legacyItalic>must have the same generic types specified</legacyItalic>. Moreover, <legacyItalic>the type names must be the same.</legacyItalic></para></listItem>
            <listItem><para>Setting some flags may result in errors when using injector creators! For instance setting the <codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.PassFields</codeEntityReference> on a static method or setting <codeInline>InjectFlags.PassParametersVal | InjectFlags.PassParametersRef</codeInline> will result in Cecil.Inject either throwing an exception or returning a <codeInline>null</codeInline> for an injector.</para></listItem>
            <listItem><para><codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.None</codeEntityReference> flag is always set! That way the return type of the injection method is always <codeInline>void</codeInline> except maybe when using the <codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.ModifyReturn</codeEntityReference> flag.</para></listItem>
           </list>
           </content>
          </section>
      </sections>
    </section>
    <section address="section_examples">
     <title>Examples</title>
     <content>
      As an example let us consider a few hooks and which <codeEntityReference>T:Mono.Cecil.Inject.InjectFlags</codeEntityReference> value they statisfy.
     </content>
     <sections>
      <section address="subsection_ex1">
       <title>Example 1: Hook with no parameters</title>
       <content>
        One needs a hook that is simply called every time the target is called. The hook does not need any parameters, tags, locals, fields nor instances. Thus the injection flag is <codeEntityReference>F:Mono.Cecil.Inject.InjectFlags.None</codeEntityReference> and the hook is
        
        <code languange="cs">
         public static void MyHook();
        </code>
        
        According to the template &lt;3&gt; = <codeInline>void</codeInline> and the rest is empty.
       </content>
      </section>
      
      <section address="subsection_ex2">
       <title>Example 2: Hook with invoking instance and target method's parameters</title>
       <content>
        One needs a hook for the method <codeInline>Foo(int v1, string v2)</codeInline> found in <legacyBold>Bar</legacyBold> class. The hook needs <codeInline>this</codeInline> value from the target method and the method's parameters by value. Thus the injection flag is <codeInline>InjectFlags.PassInvokingInstance | InjectFlags.PassParametersVal</codeInline> and the hook itself is
        
        <code languange="cs">
         public static void MyHook2(Bar self, int v1, string v2);
        </code>
        
        Here the template is &lt;2&gt; = <codeInline>Bar</codeInline>, &lt;3&gt; = <codeInline>void</codeInline>, &lt;7&gt; = <codeInline>int, string</codeInline> and the rest is empty.
       </content>
      </section>
      
      <section address="subsection_ex1">
       <title>Example 3: Hook with invoking instance, method redirection, class fields and parameters (one of which is generic)</title>
       <content>
        One needs a hook for the method <codeInline>T[] Foo&lt;T&gt;(List&lt;T&gt; v1, byte[] v2, byte v3)</codeInline> found in the class <legacyBold>Bar</legacyBold>. The hooks needs <codeInline>this</codeInline> value, class field <codeInline>uint barField</codeInline> and the target's parameters. The hook should also be injected by method redirection. Thus the injection flag is <codeInline>InjectFlags.PassInvokingInstance | InjectFlags.ModifyReturn | InjectFlags.PassFields | InjectFlags.PassParametersVal</codeInline> and the hook's signature is
        
        <code languange="cs">
         public static bool MyHook3&lt;T&gt;(Bar self, out T[] ret, ref uint barField, List&lt;T&gt; v1, byte[] v2, byte v3);
        </code>
        
        Here the template is &lt;2&gt; = <codeInline>Bar</codeInline>, &lt;3&gt; = <codeInline>bool</codeInline>, &lt;4&gt; = <codeInline>out T[]</codeInline>, &lt;6&gt; = <codeInline>ref uint</codeInline>, &lt;7&gt; = <codeInline>List&lt;T&gt;, byte[], byte</codeInline>.
       </content>
      </section>
     </sections>
    </section>
    <relatedTopics>
    </relatedTopics>
  </developerConceptualDocument>
</topic>