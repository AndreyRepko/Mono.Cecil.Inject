<?xml version="1.0" encoding="utf-8"?>
<topic id="ovr_method_get_and_match" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <!--
    <summary>
      <para>Optional summary abstract</para>
    </summary>
    -->
    <introduction>
      <autoOutline />
      <para>
      	Most of the time Mono.Cecil is used to work on methods. 
      	That is why most of the method searching functionality found in System.Reflection was ported to Mono.Cecil.
      </para>
      <para>
      	The following methods are extensions to <legacyBold>TypeDefinition</legacyBold> class found in Mono.Cecil. 
      	That means you can call the methods just like if it were part of <legacyBold>TypeDefinition</legacyBold> itself. 
      	For example, the following snippet finds a method named <legacyBold>Foo</legacyBold> found in type <legacyBold>Bar</legacyBold> from a pre-loaded assembly.
      
      	<code language="cs" numberLines="true">
			AssemblyDefinition assembly;
			// ... assembly is loaded into memory ...

			TypeDefinition bar = assembly.MainModule.GetType("Bar");
			MethodDefinition foo = bar.GetMethod("Foo");                             // Using the extension method as if it were native
			MethodDefinition foo2 = TypeDefinitionExtensions.GetMethod(bar, "Foo");  // This also works
		</code>
      </para>
    </introduction>
    <section address="section_getting_method">
      <title>Getting method definitions</title>
      <content>
        <para>
        	The most basic extension method is <codeEntityReference autoUpgrade="true">M:Mono.Cecil.Inject.TypeDefinitionExtensions.GetMethod(Mono.Cecil.TypeDefinition,System.String)</codeEntityReference> that only searches for a method with a specified name or/and parameters. <markup><br/></markup>
			In addition, the <codeEntityReference linkText="GetMethods">M:Mono.Cecil.Inject.TypeDefinitionExtensions.GetMethods(Mono.Cecil.TypeDefinition,System.String)</codeEntityReference> method searches and returns all the methods within a <legacyBold>TypeDefinition</legacyBold> that have the specified name. If no matching methods are found, the method returns an empty array.
        </para>
        <para>
        	If you only need a single method, consider using <codeEntityReference autoUpgrade="true">M:Mono.Cecil.Inject.TypeDefinitionExtensions.GetMethod(Mono.Cecil.TypeDefinition,System.String)</codeEntityReference> that finds the first matching occurrence on <codeInline>null</codeInline> if no matches are found. 
        	The method comes in two flavours: <legacyItalic>name-only</legacyItalic> and <legacyItalic>name-and-parameters</legacyItalic>. The former variant has only a single parameter -- the name of the method to search for. Using the latter version you can also specify the type of the parameters the method should have.
        	Note that
        	
			<list class="bullet">
  				<listItem><para>The order of the parameters must be the same as defined in the method itself</para></listItem>
  				<listItem><para>There are multiple overrides of *name-and-parameters* variant depending on the type of the parameter type they accept. Internally they all return the same method for the same set of parameters.</para></listItem>
			</list>
        </para>
        <para>
        	As an example, consider a type <legacyBold>Bar</legacyBold> that has two methods in it: <codeInline>Foo()</codeInline> and <codeInline>Foo(string foo1, bool foo2)</codeInline>. The snippet below shows how to use the above methods
        	
        	<code language="cs" numberLines="true">
        		AssemblyDefinition assembly;
				// ... assembly is loaded into memory

				TypeDefinition bar = assembly.MainModule.GetType("Bar");

				MethodDefinition[] foos = bar.GetMethods("Foo");    // Returns an array of all Foo methods
				MethodDefinition foo1 = bar.GetMethod("Foo");       // Returns Foo()

				// NOTE: The following methods are all equivalent (they return the same method -- that is Foo(string foo1, bool foo2))
				// WAY 1: Using TypeReference from Mono.Cecil
				MethodDefinition foo2 = bar.GetMethod("Foo", assembly.MainModule.Import(typeof(string)), assembly.MainModule.Import(typeof(bool));
				// WAY 2: Using Type from System
				MethodDefinition foo3 = bar.GetMethod("Foo", typeof(string), typeof(bool));
				// WAY 3: Using types' string representation
				MethodDefinition foo4 = bar.GetMethod("Foo", "System.String", "System.Boolean");

				MethodDefintion none = bar.GetMethod("Baz");       // Returns null, since there are no such methods in Bar
        	</code>
        </para>
      </content>
    </section>
    <section address="section_method_matching">
     <title>Method matching</title>
     <content>
      <para>
       In addition to getting methods, you can also search for methods that only partially match with the specified parameter types. 
       That is done with the <codeEntityReference autoUpgrade="true">M:Mono.Cecil.Inject.TypeDefinitionExtensions.MatchMethod(Mono.Cecil.TypeDefinition,System.String,System.Type[])</codeEntityReference> method.<markup><br/></markup>
       While the signatures are almost the same as those of <codeEntityReference autoUpgrade="true">M:Mono.Cecil.Inject.TypeDefinitionExtensions.GetMethod(Mono.Cecil.TypeDefinition,System.String)</codeEntityReference> there are a few key differences:
      
      <list class="bullet">
       <listItem><para><codeEntityReference autoUpgrade="true">M:Mono.Cecil.Inject.TypeDefinitionExtensions.MatchMethod(Mono.Cecil.TypeDefinition,System.String,System.Type[])</codeEntityReference> returns methods that have <legacyItalic>at least</legacyItalic> the specfied parameters.</para></listItem>
       <listItem><para><codeEntityReference autoUpgrade="true">M:Mono.Cecil.Inject.TypeDefinitionExtensions.MatchMethod(Mono.Cecil.TypeDefinition,System.String,System.Type[])</codeEntityReference> returns all methods that match, which is why it returns an array.</para></listItem>
      </list>
	 
	  <alert class="caution"><codeEntityReference autoUpgrade="true">M:Mono.Cecil.Inject.TypeDefinitionExtensions.MatchMethod(Mono.Cecil.TypeDefinition,System.String,System.Type[])</codeEntityReference> is order-sensitive! That means that it only matches methods that have the provided parameters in the right order.</alert>
	 </para>
	 
	 <para>
	  As an example, consider a type <legacyBold>Bar</legacyBold> that has methods <codeInline>Foo(string foo1, bool foo2)</codeInline>, <codeInline>Foo(string foo1, int foo2)</codeInline> and <codeInline>Foo(int foo1, string foo2)</codeInline>. The snippet below shows how to use the matching methods. 
	  <legacyItalic>Here we use only one override, but just as with <codeEntityReference autoUpgrade="true">M:Mono.Cecil.Inject.TypeDefinitionExtensions.GetMethod(Mono.Cecil.TypeDefinition,System.String)</codeEntityReference>, all the variations are the same.</legacyItalic>
	  
	  <code language="cs" numberLines="true">
	   AssemblyDefinition assembly;
       // ... assembly is loaded into memory

       TypeDefinition bar = assembly.MainModule.GetType("Bar");

       MethodDefinition[] foos1 = bar.MatchMethod("Foo", typeof(string));   // Returns Foo(string foo1, bool foo2) and Foo(string foo1, int foo2)
       MethodDefinition[] foos2 = bar.MatchMethod("Foo", typeof(int));      // Returns Foo(int foo1, string
	  </code>
     </para>
     </content>
    </section>
    <section address="section_field_searching">
     <title>Field searching</title>
     <content>
      <para>
       Cecil.Inject provides a very small helper to search for member fields -- <codeEntityReference autoUpgrade="true" linkText="GetField">M:Mono.Cecil.Inject.TypeDefinitionExtensions.GetField(Mono.Cecil.TypeDefinition,System.String)</codeEntityReference>.
       The method merely returns the first field it finds that matches the provided name.
      </para>
      
      <para>
       As an example, consider a type <legacyBold>Bar</legacyBold> that has a field <codeInline>int foo</codeInline> (the accessibility does not matter). The method can be then used as follows
       
       <code language="cs" numberLines="true">
        AssemblyDefinition assembly;
        // ... assembly is loaded into memory

        TypeDefinition bar = assembly.MainModule.GetType("Bar");

        FieldDefinition foo = bar.GetField("foo");
       </code>
      </para>
     </content>
    </section>
    <relatedTopics>
    </relatedTopics>
  </developerConceptualDocument>
</topic>