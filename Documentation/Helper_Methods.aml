<?xml version="1.0" encoding="utf-8"?>
<topic id="ovr_helper_methods" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <!--
    <summary>
      <para>Optional summary abstract</para>
    </summary>
    -->
    <introduction>
      <!-- Uncomment this to generate an outline of the section and sub-section
           titles.  Specify a numeric value as the inner text to limit it to
           a specific number of sub-topics when creating the outline.  Specify
           zero (0) to limit it to top-level sections only.  -->
      <!-- <autoOutline /> -->
      <para>
       In addition to main methods, like method finding and injecting, Cecil.Inject provides a few additional helpers to work with managed .NET assemblies.
       Cecil.Inject attempts to expose as many utility methods as it can, from collection utilities to instruction manipulation. In this chapter we will discuss
       only the main helper methods.
      </para>
    </introduction>
    <!-- Add one or more top-level section elements.  These are collapsible.
         If using <autoOutline />, add an address attribute to identify it
         and specify a title so that it can be jumped to with a hyperlink. -->
    <section address="section_change_access">
      <title>Changing access of different elements</title>
      <content>
        <!-- Uncomment this to create a sub-section outline
        <autoOutline /> -->
        <para>
         Cecil.Inject provides a convenience method <codeEntityReference linkText="ChangeAccess">M:Mono.Cecil.Inject.TypeDefinitionExtensions.ChangeAccess(Mono.Cecil.TypeDefinition,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)</codeEntityReference>.
         The method is an extension to <legacyBold>TypeDefinition</legacyBold> class of Mono.Cecil and allows to easily change the accessibility of classes, structures, enumerations, methods, memebr fields and nested classes.
         <markup><br/></markup>
         The methods takes a regular expression and a combination of different parameters that specify how to make change access. Refer to the <codeEntityReference linkText="documentation of ChangeAccess">M:Mono.Cecil.Inject.TypeDefinitionExtensions.ChangeAccess(Mono.Cecil.TypeDefinition,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)</codeEntityReference> to get more information.
        </para>
        <para>
         As an example, consider a private class <legacyBold>Bar</legacyBold> with a private field <codeInline>int fInt</codeInline>, a private method <codeInline>Foo</codeInline> and a private nested class <legacyBold>Baz</legacyBold> which contains a private field <codeInline>byte fBazByte</codeInline>.
         <markup><br/></markup>
         We can make all the elements public by using the following expressions:
         
         <code language="cs" numberLines="true">
          // Type definition for Bar
          TypeDefinition bar;
          
          // Get type definition for Bar
          
          // WAY 1: Make everything public one at the time
          bar.IsPublic = true;
          bar.IsPrivate = false;
          
          bar.ChangeAccess("fInt");
          bar.ChangeAccess("Foo", makeVirtual: false);
          bar.ChangeAccess("Baz");
          bar.ChangeAccess("Baz|fBazByte", recursive: true); // RegEx: Match for type Baz and fBazByte (that is inside Baz)
          
          // WAY 2: Make everything public at once
          bar.IsPublic = true;
          bar.IsPrivate = false;
          bar.ChangeAccess("*", makeVirtual: false, recursive: true);
         </code>
         
         Note that this is merely a convenience method to make access changing on multiple elements fast. For more precise
         control on how to change access, consider using <legacyBold>IsPublic</legacyBold> and <legacyBold>IsPrivate</legacyBold> properties (along with some other ones)
         of Mono.Cecil.
        </para>
      </content>
    </section>
    <section address="section_param_helper">
     <title>Type creation</title>
     <content>
      <para>
       While method searching does type conversion automatically for you, sometimes you would want to do the type creation yourself.
       One of those instances is when you are searching for methods with generic parameters and you need to specify an exact name for the generic parameter type.
       That, and much more can be done with methods found in <codeEntityReference>T:Mono.Cecil.Inject.ParamHelper</codeEntityReference> class.
       <markup><br/></markup>
       The class contains methods to create <legacyBold>TypeReference</legacyBold>s from <codeEntityReference>T:System.Type</codeEntityReference>.
       In addition, the <codeEntityReference>M:Mono.Cecil.Inject.ParamHelper.CreateDummyType(System.String)</codeEntityReference> and <codeEntityReference>M:Mono.Cecil.Inject.ParamHelper.CreateGeneric(System.String)</codeEntityReference> methods allow to create custom
       generic types with a specified name.
      </para>
      <para>
       Here is an example that shows how to create various types with the provided methods.
       
       <code languange="cs" numberLines="true">
        // Type reference for System.Int32   
        TypeReference intType = ParamHelper.FromType(typeof(int));
        
        // Type reference for System.String
        TypeReference stringType = ParamHelper.FromType&lt;string&gt;();
        
        // Type reference for List&lt;T&gt;
        TypeReference listType = ParamHelper.FromType(typeof(List&lt;&gt;).MakeGenericType(new[] { ParamHelper.CreateDummyType("T") }));
        
        // Type reference for Dictionary&lt;U, List&lt;T&gt;&gt;
        TypeReference woahType = ParamHelper.FromType(typeof(Dictionary&lt;,&gt;).MakeGenericType(new[] { ParamHelper.CreateDummyType("U"), typeof(List&lt;&gt;).MakeGenericType(new[] { ParamHelper.CreateDummyType("T") }) }));
       </code>
      </para>
     </content>
    </section>
    <section address="section_inject_flags_helpers">
     <title>Injection flags manipulation</title>
     <content>
      <para>
       To make the manipulation of different values of <codeEntityReference>T:Mono.Cecil.Inject.InjectFlags</codeEntityReference> easier,
       Cecil.Inject provides extension methods found in <codeEntityReference>T:Mono.Cecil.Inject.InjectFlagMethods</codeEntityReference> and a special <codeEntityReference>T:Mono.Cecil.Inject.InjectValues</codeEntityReference> class
       that allows to manipulate injection flags as booleans instead of using logical OR operations.
      </para>
      <para>
       Here are a few examples on how to use the <codeEntityReference>T:Mono.Cecil.Inject.InjectValues</codeEntityReference> class:
       
       <code languange="cs" numberLines="true">
        InjectFlags flags = InjectFlags.ModifyReturn | InjectFlags.PassLocals | InjectFlags.PassParametersVal;
        InjectValues values = flags.ToValues(); // Or use new InjectValues(flags)
        
        // Check if a certain option is set
        if(values.ModifyReturn)
        	Console.WriteLine("ModifyReturn is set!")
        	
        if(values.ParameterType == InjectValues.PassParametersType.ByValue)
        	Console.WriteLine("Passing parameters by value");
        else if(values.ParameterType == InjectValues.PassParametersType.ByReference)
        	Console.WriteLine("Passing parameters by reference");
        else
        	Console.WriteLine("No parameters are passed!")
        
        // Modifying the values
        values.PassLocals = false;
        values.PassFields = true;
        
        // Converting back to InjectFlags
        flags = values.GetCombinedFlags();
        
        // The new value of flags is InjectFlags.ModifyReturn | InjectFlags.PassFields | InjectFlags.PassParametersVal
       </code>
      </para>
     </content>
    </section>
    <section>
     <title>Assembly loading</title>
     <content>
      <para>
       Finally, Cecil.Inject provides a simple <codeEntityReference>M:Mono.Cecil.Inject.AssemblyLoader.LoadAssembly(System.String)</codeEntityReference> method to load
       assemblies into Mono.Cecil. The assembly may be of any type (a DLL or an executable), as long as it is a managed .NET assembly.       
      </para>
      <para>
       Here are a few examples on how to use the method:
       
       <code languange="cs" numberLines="true">
        // Load an assembly from a relative path
        AssemblyDefinition asmDef = AssemblyLoader.LoadAssembly("Foo.dll");
        
        // Load an assembly from an aboslute path
        AssemblyDefinition asmDef2 = AssemblyLoader.LoadAssembly(@"D:\AssemblyFolder\Bar.dll");
       </code>
      </para>
     </content>
    </section>
    <relatedTopics>
      <!-- One or more of the following:
           - A local link
           - An external link
           - A code entity reference

      <link xlink:href="Other Topic's ID"/>
      <link xlink:href="Other Topic's ID">Link inner text</link>

      <externalLink>
          <linkText>Link text</linkText>
          <linkAlternateText>Optional alternate link text</linkAlternateText>
          <linkUri>URI</linkUri>
      </externalLink>

      <codeEntityReference>API member ID</codeEntityReference>

      Examples:

      <link xlink:href="00e97994-e9e6-46e0-b420-5be86b2f8270" />
      <link xlink:href="00e97994-e9e6-46e0-b420-5be86b2f8278">Some other topic</link>

      <externalLink>
          <linkText>SHFB on GitHub</linkText>
          <linkAlternateText>Go to GitHub</linkAlternateText>
          <linkUri>https://GitHub.com/EWSoftware/SHFB</linkUri>
      </externalLink>

      <codeEntityReference>T:TestDoc.TestClass</codeEntityReference>
      <codeEntityReference>P:TestDoc.TestClass.SomeProperty</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.#ctor</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.#ctor(System.String,System.Int32)</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.ToString</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.FirstMethod</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.SecondMethod(System.Int32,System.String)</codeEntityReference>
      -->
    </relatedTopics>
  </developerConceptualDocument>
</topic>